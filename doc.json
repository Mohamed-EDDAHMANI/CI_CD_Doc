{
  "title": "Documentation CI/CD",
  "sections": [
    {
      "heading": "1. Introduction au CI/CD",
      "content": "CI/CD signifie Intégration Continue et Déploiement Continu (ou Livraison Continue)...",
      "Explication": "En résumé : CI/CD est comme une chaîne de montage automatique pour le code..."
    },
    {
      "heading": "2. Intégration Continue (CI)",
      "content": "L'Intégration Continue est la pratique...",
      "Explication": "Pensez-y comme un contrôle de qualité automatique..."
    },
    {
      "heading": "3. Livraison Continue (CD)",
      "content": "La Livraison Continue garantit que les modifications...",
      "Explication": "C'est comme avoir un colis Amazon toujours prêt à être expédié..."
    },
    {
      "heading": "4. Déploiement Continu",
      "content": "Le Déploiement Continu va un pas plus loin...",
      "Explication": "Le niveau supérieur : non seulement le colis est prêt..."
    },
    {
      "heading": "5. Avantages du CI/CD",
      "content": "• Cycles de release plus rapides...",
      "Explication": "En gros : vous livrez plus vite, avec moins d'erreurs..."
    },
    {
      "heading": "6. Concepts Clés",
      "content": "• Pipeline : Séquence d'étapes automatisées...",
      "Explication": "Le vocabulaire de base : Pipeline = tuyau..."
    },
    {
      "heading": "7. Outils CI/CD Courants",
      "content": "• GitHub Actions : Outil CI/CD intégré...",
      "Explication": "Ce sont les robots qui font le travail pour vous..."
    },
    {
      "heading": "8. Workflow Exemple (Étape par Étape)",
      "content": "1. Le développeur pousse le code...",
      "Explication": "Le parcours de votre code : vous l'envoyez..."
    },
    {
      "heading": "9. Exemple de Pipeline CI/CD (YAML - GitHub Actions)",
      "content": "```yaml\nname: CI/CD Pipeline\non:\n  push:\n    branches: [ main, develop ]\n  pull_request:\n    branches: [ main ]\n...```",
      "Explication": "C'est la recette de cuisine pour GitHub Actions...",
      "ExplicationDetaillee": {
        "Résumé": "Le pipeline est divisé en quatre étapes principales..."
      }
    },
    {
      "heading": "10. Bonnes Pratiques",
      "content": "• Maintenir des builds rapides...",
      "Explication": "Les règles d'or : gardez votre pipeline rapide..."
    },
    {
      "heading": "11. CI/CD dans la Culture DevOps",
      "content": "Le CI/CD est une pratique fondamentale de DevOps...",
      "Explication": "DevOps, c'est faire travailler les développeurs..."
    },
    {
      "heading": "12. Exemple Réel",
      "content": "Dans un projet React + Node.js, vous pouvez configurer...",
      "Explication": "Scénario concret : vous codez une app web React..."
    },
    {
      "heading": "13. Métriques et Surveillance",
      "content": "Pour mesurer l'efficacité de votre pipeline CI/CD...",
      "Explication": "Comment savoir si votre CI/CD fonctionne bien ?..."
    },
    {
      "heading": "14. Défis et Solutions",
      "content": "Défis courants et comment les résoudre...",
      "Explication": "Les problèmes fréquents : des tests qui marchent parfois..."
    },
    {
      "heading": "15. Conclusion",
      "content": "Le CI/CD ne se limite pas à l'automatisation...",
      "Explication": "Le message final : CI/CD n'est pas juste des outils..."
    },
    {
      "heading": "16. Différences entre CI/CD dans GitHub Actions et GitLab CI",
      "content": "GitHub Actions et GitLab CI sont deux plateformes populaires pour l’automatisation CI/CD. Bien qu’elles poursuivent le même objectif, leurs approches et intégrations diffèrent :\n\n**1️⃣ Intégration et Hébergement :**\n- GitHub Actions est intégré nativement à GitHub, idéal pour les projets hébergés sur GitHub.\n- GitLab CI est intégré à GitLab, avec des fonctionnalités DevOps complètes (CI/CD, gestion des issues, conteneurs, monitoring, etc.).\n\n**2️⃣ Configuration :**\n- GitHub Actions utilise le fichier `.github/workflows/*.yml`.\n- GitLab CI utilise `.gitlab-ci.yml` à la racine du dépôt.\n\n**3️⃣ Runners :**\n- GitHub propose des *runners* hébergés (Ubuntu, Windows, macOS) et personnalisés.\n- GitLab permet d’enregistrer ses propres *runners* (self-hosted) très facilement, souvent utilisé dans les entreprises.\n\n**4️⃣ Sécurité et Permissions :**\n- GitHub gère les secrets via *GitHub Secrets*.\n- GitLab a un système plus avancé avec *Variables de CI/CD* et gestion des environnements.\n\n**5️⃣ Visualisation et Monitoring :**\n- GitLab CI offre une visualisation claire du pipeline avec des stages et des jobs.\n- GitHub Actions affiche les workflows dans l’onglet *Actions*, mais la vue pipeline est plus simple.\n\n**6️⃣ Coût et Ressources :**\n- GitHub offre un certain nombre de minutes gratuites, puis payantes.\n- GitLab Community Edition est gratuit et auto-hébergeable, ce qui séduit les équipes internes.\n\n**Conclusion :**\n- GitHub Actions → idéal pour projets open-source ou hébergés sur GitHub.\n- GitLab CI → plus complet pour entreprises avec infrastructure privée et pipelines complexes.",
      "Explication": "GitHub Actions est plus simple et intégré à GitHub, GitLab CI est plus complet et personnalisable. Si GitHub Actions est une voiture automatique, GitLab CI est une voiture manuelle : plus de contrôle, mais plus de configuration."
    }
  ],

  "docker": {
    "title": "Docker",
    "sections": [
      {
        "heading": "1. Introduction à Docker",
        "content": "Docker est une plateforme de conteneurisation qui permet d’exécuter des applications dans des environnements isolés appelés *conteneurs*. Chaque conteneur contient tout ce dont une application a besoin (code, dépendances, bibliothèques, configurations).",
        "Explication": "Docker, c’est comme une boîte dans laquelle vous mettez votre application et tout ce qu’elle utilise, afin qu’elle fonctionne exactement de la même façon sur tous les ordinateurs."
      },
      {
        "heading": "2. Pourquoi Docker ?",
        "content": "• Supprime le problème du 'ça marche chez moi'\n• Standardise les environnements de développement\n• Permet le déploiement rapide et portable\n• Facilite la mise à l’échelle (scalabilité)\n• Intégration simple avec CI/CD",
        "Explication": "Avec Docker, votre code fonctionne partout, sans surprise. Finies les différences entre vos machines et les serveurs."
      },
      {
        "heading": "3. Concepts de Base",
        "content": "• **Image** : modèle immuable servant à créer un conteneur\n• **Conteneur** : instance exécutable d’une image\n• **Dockerfile** : fichier décrivant comment construire une image\n• **Docker Hub** : registre public d’images Docker\n• **Volume** : stockage persistant pour les données\n• **Network** : permet la communication entre conteneurs",
        "Explication": "Pensez à une image comme une recette, et au conteneur comme le plat préparé. Le Dockerfile est la fiche recette écrite par le chef."
      },
      {
        "heading": "4. Workflow Docker Typique",
        "content": "1️⃣ Écrire un Dockerfile\n2️⃣ Construire une image avec `docker build`\n3️⃣ Lancer un conteneur avec `docker run`\n4️⃣ Gérer les conteneurs avec `docker ps`, `docker stop`, `docker rm`\n5️⃣ Pousser l’image sur Docker Hub avec `docker push`\n6️⃣ Déployer via CI/CD ou Kubernetes",
        "Explication": "C’est comme construire, tester et envoyer votre application dans une boîte prête à l’emploi."
      },
      {
        "heading": "5. Exemple de Dockerfile pour une App React + Node.js",
        "content": "```Dockerfile\n# Étape 1 : Build du frontend\nFROM node:18 AS build\nWORKDIR /app\nCOPY frontend/ ./frontend\nRUN cd frontend && npm install && npm run build\n\n# Étape 2 : Backend\nFROM node:18\nWORKDIR /app\nCOPY backend/ ./backend\nCOPY --from=build /app/frontend/build ./backend/public\nRUN cd backend && npm install\nCMD [\"node\", \"backend/server.js\"]\n```",
        "Explication": "Ce Dockerfile construit d’abord le frontend, puis copie les fichiers compilés dans le backend avant de lancer le serveur."
      },
      {
        "heading": "6. Avantages",
        "content": "• Portabilité\n• Isolation\n• Légèreté\n• Rapidité de déploiement\n• Compatibilité avec Kubernetes et CI/CD",
        "Explication": "Docker rend vos applications indépendantes du système sur lequel elles tournent, et c’est exactement ce que veulent les équipes modernes."
      }
    ]
  },

  "kubernetes": {
    "title": "Kubernetes",
    "sections": [
      {
        "heading": "1. Introduction à Kubernetes",
        "content": "Kubernetes (souvent abrégé K8s) est un système open-source d’orchestration de conteneurs. Il automatise le déploiement, la mise à l’échelle et la gestion des applications conteneurisées.",
        "Explication": "Kubernetes, c’est comme un chef d’orchestre qui gère des dizaines de conteneurs Docker et s’assure qu’ils travaillent ensemble sans problème."
      },
      {
        "heading": "2. Pourquoi utiliser Kubernetes ?",
        "content": "• Automatisation du déploiement et du scaling\n• Haute disponibilité\n• Auto-réparation des conteneurs\n• Gestion des ressources\n• Intégration native avec Docker et CI/CD",
        "Explication": "Kubernetes surveille vos conteneurs : s’ils plantent, il les relance tout seul. Si la charge augmente, il ajoute de nouvelles copies automatiquement."
      },
      {
        "heading": "3. Concepts Clés",
        "content": "• **Pod** : plus petite unité, contient un ou plusieurs conteneurs\n• **Node** : machine (physique ou virtuelle) exécutant les Pods\n• **Cluster** : ensemble de Nodes gérés par Kubernetes\n• **Deployment** : décrit comment déployer et mettre à jour des Pods\n• **Service** : expose une application (accès réseau)\n• **Ingress** : gère les routes HTTP/HTTPS\n• **ConfigMap & Secret** : configuration et données sensibles\n• **Namespace** : isolation logique au sein d’un cluster",
        "Explication": "Un Pod, c’est une boîte Docker ; un Cluster, c’est un ensemble de boîtes bien organisées."
      },
      {
        "heading": "4. Exemple de Fichier Deployment",
        "content": "```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: react-app\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: react-app\n  template:\n    metadata:\n      labels:\n        app: react-app\n    spec:\n      containers:\n      - name: react-container\n        image: mohamed/react-app:latest\n        ports:\n        - containerPort: 80\n```",
        "Explication": "Ce fichier déploie 3 copies (réplicas) de votre application React. Si une tombe, Kubernetes en crée une nouvelle."
      },
      {
        "heading": "5. Intégration Docker + Kubernetes",
        "content": "Docker construit les conteneurs, Kubernetes les gère. On peut dire que Docker crée les 'briques', et Kubernetes construit le 'bâtiment' avec ces briques.\n\nWorkflow typique :\n1️⃣ Docker build → création des images\n2️⃣ Push vers Docker Hub\n3️⃣ Kubernetes les déploie via un fichier YAML",
        "Explication": "Docker = un conteneur. Kubernetes = un gestionnaire de conteneurs. Ensemble, ils forment une architecture moderne, scalable et résiliente."
      },
      {
        "heading": "6. Avantages",
        "content": "• Scalabilité automatique\n• Résilience et tolérance aux pannes\n• Portabilité multi-cloud\n• Intégration native avec CI/CD\n• Déploiement progressif (rolling updates)",
        "Explication": "Kubernetes vous aide à dormir tranquille : si un serveur tombe, tout continue à tourner sans interruption."
      }
    ]
  },
  "pipelinesExamples": {
    "title": "Exemples de Pipelines CI/CD",
    "examples": [
      {
        "name": "Pipeline React + Node.js (GitHub Actions)",
        "content": "```yaml\nname: React + Node CI/CD\non:\n  push:\n    branches: [ main ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Setup Node\n        uses: actions/setup-node@v3\n        with:\n          node-version: 18\n      - name: Install dependencies\n        run: npm install --legacy-peer-deps\n      - name: Run tests\n        run: npm test\n      - name: Build project\n        run: npm run build\n      - name: Deploy to Vercel\n        run: npx vercel --prod --token=${{ secrets.VERCEL_TOKEN }}\n```",
        "Explication": "Pipeline simple qui build, teste et déploie automatiquement sur Vercel."
      },
      {
        "name": "Pipeline Docker + GitHub Actions",
        "content": "```yaml\nname: Build & Push Docker Image\non:\n  push:\n    branches: [ main ]\n\njobs:\n  docker:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Build Docker image\n        run: docker build -t mohamed/app:latest .\n      - name: Login to Docker Hub\n        run: echo ${{ secrets.DOCKER_PASSWORD }} | docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin\n      - name: Push image\n        run: docker push mohamed/app:latest\n```",
        "Explication": "Ce pipeline construit et pousse automatiquement une image Docker sur Docker Hub."
      },
      {
        "name": "Pipeline GitLab CI pour Node.js",
        "content": "```yaml\nstages:\n  - install\n  - test\n  - deploy\n\ninstall:\n  stage: install\n  script:\n    - npm install\n\ntest:\n  stage: test\n  script:\n    - npm test\n\ndeploy:\n  stage: deploy\n  script:\n    - npm run deploy\n  only:\n    - main\n```",
        "Explication": "Pipeline GitLab simple avec trois étapes : installation, test et déploiement."
      }
    ]
  }
}
